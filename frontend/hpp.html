<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AKS Hospital - Final Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #dceefb; font-family: 'Segoe UI', Roboto, sans-serif; }
        
        /* UI: Main Header */
        #main-header {
            position: absolute; top: 25px; left: 30px; z-index: 100; pointer-events: none;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        #main-header h1 { margin: 0; color: #002855; font-size: 2.2rem; font-weight: 800; letter-spacing: 1px; }
        #main-header p { margin: 5px 0 0 0; color: #d32f2f; font-size: 1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; }

        /* UI: Location Icon */
        #location-fixed {
            position: absolute; top: 25px; right: 30px; z-index: 100; display: flex; align-items: center;
            background: rgba(255, 255, 255, 0.9); padding: 10px 15px; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); cursor: pointer; transition: all 0.3s ease;
        }
        #location-fixed:hover { background: white; transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .loc-icon { font-size: 1.8rem; margin-right: 5px; }
        .loc-text {
            font-weight: 700; color: #002855; font-size: 1rem; max-width: 0; overflow: hidden;
            white-space: nowrap; opacity: 0; transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        #location-fixed:hover .loc-text { max-width: 200px; opacity: 1; margin-left: 10px; }

        /* UI: Tooltip */
        #dept-tooltip {
            position: absolute; display: none; background: rgba(0, 40, 85, 0.95); color: #fff;
            padding: 12px 18px; border-radius: 8px; font-size: 14px; font-weight: 500;
            pointer-events: none; z-index: 200; white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); border-left: 4px solid #ffcc00;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="main-header">
        <h1>AKS HOSPITAL</h1>
        <p>Where Health Meets Excellence</p>
    </div>
    <div id="location-fixed">
        <span class="loc-icon">üìç</span>
        <span class="loc-text">Lahore, Pakistan</span>
    </div>
    <div id="dept-tooltip"></div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdceefb); 
        scene.fog = new THREE.FogExp2(0xdceefb, 0.0015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.02;
        controls.minDistance = 50;
        controls.maxDistance = 350;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const mouseRaw = { x: 0, y: 0 };
        const tooltip = document.getElementById('dept-tooltip');
        let hoverObject = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            mouseRaw.x = event.clientX;
            mouseRaw.y = event.clientY;
        }
        window.addEventListener('mousemove', onMouseMove, false);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xfffce0, 1.2);
        dirLight.position.set(-80, 120, 80);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.top = 150; dirLight.shadow.camera.bottom = -150;
        dirLight.shadow.camera.left = -150; dirLight.shadow.camera.right = 150;
        scene.add(dirLight);

        // --- 3. MATERIALS ---
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 }); 
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x223344, roughness: 0.4, metalness: 0.4 }); 
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x112211, roughness: 1 });
        const pavementMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.7 });
        const brickMat = new THREE.MeshStandardMaterial({ color: 0x884433 });
        const planterMat = new THREE.MeshStandardMaterial({ color: 0x664422, roughness: 0.9 });
        const bushMat = new THREE.MeshStandardMaterial({ color: 0x3a5a2a, roughness: 0.8 });
        const benchSeatMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 });
        const benchFrameMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });

        // --- 4. BUILDER FUNCTIONS ---
        function createBox(w, h, d, x, y, z, mat, cast=true, receive=true) {
            const geom = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = cast;
            mesh.receiveShadow = receive;
            return mesh;
        }

        function createBuildingBlock(w, h, d, x, z, floors) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            group.add(createBox(w, h, d, 0, h/2, 0, wallMat));
            const floorHeight = h / floors;
            const winH = floorHeight * 0.6;
            for(let i = 0; i < floors; i++) {
                const yPos = (i * floorHeight) + floorHeight/2;
                addWindowRow(group, w, d, yPos, winH, 1);
                addWindowRow(group, w, d, yPos, winH, -1);
                if(d > 8) {
                   addSideWindowRow(group, h, d, yPos, winH, w, 1);
                   addSideWindowRow(group, h, d, yPos, winH, w, -1);
                }
            }
            group.add(createBox(w+0.5, 0.5, d+0.5, 0, h, 0, frameMat));
            scene.add(group);
            return group;
        }

        function addWindowRow(group, w, d, y, h, zDir) {
            const zPos = (d/2 + 0.1) * zDir;
            const count = Math.floor(w / 3.5);
            const step = w / count;
            const start = -(w/2) + step/2;
            for(let i=0; i<count; i++) {
                const xPos = start + (i*step);
                group.add(createBox(2.2, h+0.2, 0.2, xPos, y, zPos, frameMat));
                group.add(createBox(2, h, 0.25, xPos, y, zPos, glassMat));
            }
        }
        function addSideWindowRow(group, buildingH, d, y, h, w, xDir) {
            const xPos = (w/2 + 0.1) * xDir;
            const count = Math.floor(d / 4);
            const step = d / count;
            const start = -(d/2) + step/2;
            for(let i=0; i<count; i++) {
                const zPos = start + (i*step);
                group.add(createBox(0.2, h+0.2, 2.2, xPos, y, zPos, frameMat));
                group.add(createBox(0.25, h, 2, xPos, y, zPos, glassMat));
            }
        }

        // --- 5. BUILD SCENE ---
        const centerTower = createBuildingBlock(20, 35, 16, 0, -5, 9); 
        createBuildingBlock(16, 22, 16, -18, -3, 6); // Left Wing
        createBuildingBlock(16, 22, 16, 18, -3, 6); // Right Wing
        createBuildingBlock(24, 18, 12, 0, -25, 4); // Rear Annex
        createBuildingBlock(12, 8, 10, 35, -25, 2); // Forensics

        // Glass Connectors
        scene.add(createBox(6, 10, 10, 0, 5, -15, glassMat)); 
        scene.add(createBox(4, 10, 6, -10, 5, -3, glassMat)); 
        scene.add(createBox(4, 10, 6, 10, 5, -3, glassMat)); 

        // Main Entrance Area
        const entrance = new THREE.Group();
        entrance.position.set(0, 0, 5); 
        entrance.add(createBox(12, 0.5, 10, 0, 4, 6, frameMat)); 
        entrance.add(createBox(1, 4, 1, -5, 2, 10, frameMat)); 
        entrance.add(createBox(1, 4, 1, 5, 2, 10, frameMat)); 
        scene.add(entrance);

        // --- 6. SIGNAGE ---
        function createTextTexture(text, bg, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bg; ctx.fillRect(0,0,512,128);
            ctx.font = 'bold 60px Arial'; ctx.fillStyle = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const signMeshes = [];

        // ROOFTOP SIGN
        const rooftopSign = new THREE.Mesh(
            new THREE.PlaneGeometry(16, 4),
            new THREE.MeshBasicMaterial({ map: createTextTexture("AKS HOSPITAL", "#002855", "#ffffff") })
        );
        // Position Z = 3.5 (Building wall is approx 3.0, Windows are 3.15). 
        // 3.5 is safe enough to avoid Z-fighting but close enough to look attached.
        rooftopSign.position.set(0, 37, 3.5);
        rooftopSign.userData = { isSign: true, info: "Lahore, Pakistan" };
        scene.add(rooftopSign);
        signMeshes.push(rooftopSign);

        // MONUMENT SIGN (GROUND)
        const monument = new THREE.Group();
        monument.position.set(0, 0, 50);
        monument.add(createBox(16, 4, 2, 0, 2, 0, brickMat));
        const signMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(14, 3),
            new THREE.MeshBasicMaterial({ map: createTextTexture("AKS HOSPITAL", "#ffffff", "#002855") })
        );
        signMesh.position.set(0, 2.5, 1.1);
        signMesh.userData = { isSign: true, info: "Lahore, Pakistan" };
        monument.add(signMesh);
        scene.add(monument);
        signMeshes.push(signMesh);

        // --- 7. LABELS & INTERACTION ---
        function createLabel(text, infoString) {
            const canvas = document.createElement('canvas');
            canvas.width = 300; canvas.height = 80;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 30, 60, 0.85)'; 
            roundRect(ctx, 0, 0, 300, 80, 10, true, false);
            ctx.font = 'bold 32px sans-serif'; ctx.fillStyle = '#ffcc00';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, 150, 40);
            
            // FIX: Removed depthTest:false. 
            // We rely on physical Z-position to keep them visible.
            const spriteMat = new THREE.SpriteMaterial({ 
                map: new THREE.CanvasTexture(canvas) 
            });
            
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(10, 2.6, 1);
            sprite.userData = { isLabel: true, info: infoString };
            return sprite;
        }
        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
            ctx.beginPath(); ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r); ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h); ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r); ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke();
        }

        const labelSprites = [];
        // FIX: Z-positions adjusted to be clearly in front of glass
        // Central Tower Face is ~3.15. Labels set to 4.5.
        // Wing Faces are ~14.15. Labels set to 15.5.
        const labelsData = [
            { t: "NEUROLOGY", x: 0, y: 30, z: 4.5, info: "Central Tower, Floor 9" },
            { t: "CARDIOLOGY", x: 0, y: 20, z: 4.5, info: "Central Tower, Floor 5-6" },
            { t: "ER / TRAUMA", x: -18, y: 8, z: 15.5, info: "East Wing, Ground Floor" },
            { t: "PEDIATRICS", x: -18, y: 18, z: 15.5, info: "East Wing, Floors 2-4" },
            { t: "RADIOLOGY", x: 18, y: 8, z: 15.5, info: "West Wing, Ground Floor" },
            { t: "ORTHOPEDICS", x: 18, y: 18, z: 15.5, info: "West Wing, Floors 2-4" },
            { t: "PHARMACY", x: -6, y: 5, z: 12.5, info: "Main Lobby, Level 1" },
            { t: "ONCOLOGY", x: 0, y: 15, z: -21, info: "Rear Care Center, North" },
            { t: "ADMIN / HR", x: 0, y: 22, z: -21, info: "Rear Care Center, South" },
            { t: "FORENSICS", x: 35, y: 10, z: -20, info: "Annex Building B" }
        ];
        labelsData.forEach(l => {
            const lbl = createLabel(l.t, l.info);
            lbl.position.set(l.x, l.y, l.z);
            scene.add(lbl);
            labelSprites.push(lbl);
        });

        // --- 8. LANDSCAPE ---
        scene.add(createBox(800, 1, 800, 0, -0.5, 0, grassMat, false, true)); 
        scene.add(createBox(140, 0.2, 120, 0, 0.1, -10, pavementMat, false, true)); // Main Plaza
        scene.add(createBox(24, 0.2, 75, 0, 0.1, 45, pavementMat, false, true)); // Driveway

        // Trees
        function addTree(x, z) {
            const trunk = createBox(0.8, 3, 0.8, x, 1.5, z, new THREE.MeshStandardMaterial({color:0x4a3328}));
            const leaves = createBox(3.5, 5, 3.5, x, 5, z, new THREE.MeshStandardMaterial({color:0x224411}));
            scene.add(trunk); scene.add(leaves);
        }
        
        addTree(-16, 30); addTree(16, 30); addTree(-16, 50); addTree(16, 50); 
        addTree(-50, -5); addTree(50, -5); 
        addTree(-30, 20); addTree(30, 20); 

        for(let i=0; i<40; i++) { 
            const angle = Math.random() * Math.PI * 2;
            const radius = 100 + Math.random() * 200; 
            addTree(Math.cos(angle)*radius, Math.sin(angle)*radius);
        }

        // Planters
        function createPlanter(x, z, width, depth) {
            const planterHeight = 1.5;
            const planter = new THREE.Group();
            planter.add(createBox(width, planterHeight, depth, x, planterHeight/2, z, planterMat));
            planter.add(createBox(width * 0.8, 1, depth * 0.8, x, planterHeight + 0.5, z, bushMat));
            scene.add(planter);
        }
        createPlanter(0, 3, 24, 6); 
        createPlanter(-18, 10, 18, 6); 
        createPlanter(18, 10, 18, 6); 
        createPlanter(0, -18, 28, 6); 

        // Benches
        function createBench(x, z, rotationY = 0) {
            const bench = new THREE.Group();
            bench.add(createBox(3, 0.2, 1, 0, 0.6, 0, benchSeatMat));
            bench.add(createBox(3, 0.6, 0.2, 0, 1.1, -0.4, benchSeatMat));
            bench.add(createBox(0.2, 0.6, 0.2, -1.2, 0.3, 0.3, benchFrameMat));
            bench.add(createBox(0.2, 0.6, 0.2, 1.2, 0.3, 0.3, benchFrameMat));
            bench.add(createBox(0.2, 0.6, 0.2, -1.2, 0.3, -0.3, benchFrameMat));
            bench.add(createBox(0.2, 0.6, 0.2, 1.2, 0.3, -0.3, benchFrameMat));
            bench.position.set(x, 0.2, z); 
            bench.rotation.y = rotationY;
            scene.add(bench);
        }
        createBench(-40, 0, Math.PI / 2); createBench(40, 0, -Math.PI / 2); 
        createBench(0, 25, 0); createBench(0, -25, Math.PI); 

        // --- 9. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            raycaster.setFromCamera(mouse, camera);
            
            const intersectsLabels = raycaster.intersectObjects(labelSprites);
            const intersectsSigns = raycaster.intersectObjects(signMeshes);

            let hit = null;
            if(intersectsLabels.length > 0) {
                hit = intersectsLabels[0].object;
            } else if (intersectsSigns.length > 0) {
                hit = intersectsSigns[0].object;
            }

            if (hit) {
                if (hoverObject !== hit) {
                    hoverObject = hit;
                    tooltip.innerText = hit.userData.info;
                    tooltip.style.display = 'block';
                    document.body.style.cursor = 'help';
                    if(hit.userData.isLabel) {
                        hit.scale.set(11, 2.85, 1);
                    }
                }
                tooltip.style.left = (mouseRaw.x + 15) + 'px';
                tooltip.style.top = (mouseRaw.y + 15) + 'px';
            } else {
                if (hoverObject) {
                    tooltip.style.display = 'none';
                    document.body.style.cursor = 'default';
                    if(hoverObject.userData.isLabel) {
                        hoverObject.scale.set(10, 2.6, 1);
                    }
                    hoverObject = null;
                }
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>